"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseWithContext = exports.OriginalPromise = void 0;
const AsyncStack_1 = require("./AsyncStack");
const _lib_1 = require("./_lib");
exports.OriginalPromise = Promise;
class PromiseWithContext extends exports.OriginalPromise {
    constructor(callback) {
        super((resolve, reject) => {
            const fork = AsyncStack_1.AsyncStack.fork();
            const wrapResolve = (0, _lib_1.createAsyncResolver)(fork, resolve);
            const wrapReject = (0, _lib_1.createAsyncResolver)(fork, reject);
            callback(wrapResolve, wrapReject);
            fork.yield();
        });
    }
    then(...args) {
        return _lib_1.callWithContext.call(this, super.then, args);
    }
    catch(...args) {
        return _lib_1.callWithContext.call(this, super.catch, args);
    }
    finally(...args) {
        return _lib_1.callWithContext.call(this, super.finally, args);
    }
}
exports.PromiseWithContext = PromiseWithContext;
// Ensure that all methods of the original Promise
// are available on the new PromiseWithContext
Object.getOwnPropertyNames(Promise).forEach((method) => {
    if (typeof Promise[method] === "function") {
        PromiseWithContext[method] =
            exports.OriginalPromise[method].bind(PromiseWithContext);
    }
});
//# sourceMappingURL=Promise.js.map