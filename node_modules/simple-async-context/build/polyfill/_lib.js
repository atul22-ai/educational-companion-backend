"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runInStack = exports.withContext = exports.createAsyncResolver = void 0;
exports.callWithContext = callWithContext;
const AsyncStack_1 = require("./AsyncStack");
const createAsyncResolver = (stack, callback, onlyOnce = true) => {
    let called = false;
    return function (...args) {
        if (onlyOnce && called)
            return;
        called = true;
        stack.yield();
        // Note: Is this fork neecessary? All tests are passing without it.
        // const fork = AsyncStack.fork()
        const result = callback.call(this, ...args);
        // fork.yield()
        return result;
    };
};
exports.createAsyncResolver = createAsyncResolver;
function callWithContext(originalCallback, args) {
    const fork = AsyncStack_1.AsyncStack.fork();
    const patchedArgs = args.map((arg) => {
        if (typeof arg === "function") {
            return (0, exports.createAsyncResolver)(fork, arg);
        }
        return arg;
    });
    const result = originalCallback.call(this, ...patchedArgs);
    fork.yield();
    return result;
}
// This function ensure that the context is passed to the callback
// That is called by the higher order function
const withContext = (originalCallback, onlyOnce = true) => {
    if (typeof originalCallback === "undefined")
        return undefined;
    return function (...args) {
        return callWithContext.call(this, originalCallback, args);
    };
};
exports.withContext = withContext;
const runInStack = (stackToUse, callback) => {
    const currentStack = AsyncStack_1.AsyncStack.getCurrent();
    stackToUse.start();
    try {
        const result = callback();
        currentStack.start();
        return result;
    }
    catch (err) {
        currentStack.start();
        throw err;
    }
};
exports.runInStack = runInStack;
//# sourceMappingURL=_lib.js.map