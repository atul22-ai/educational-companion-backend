/**
 * API Result for a single agent data item
 */
type AgentData = {
    id?: string | null;
    agent_slug: string;
    collection?: string;
    data: {
        [key: string]: unknown;
    };
    created_at?: string | null;
    updated_at?: string | null;
};
/**
 * API Result for a single group in the aggregate response
 */
type AggregateGroup = {
    group_key: {
        [key: string]: unknown;
    };
    count?: number | null;
    first_item?: {
        [key: string]: unknown;
    } | null;
};
/**
 * API request body for aggregating agent data
 */
type AggregateRequest = {
    /**
     * The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.
     */
    page_size?: number | null;
    /**
     * A page token, received from a previous list call. Provide this to retrieve the subsequent page.
     */
    page_token?: string | null;
    /**
     * A filter object or expression that filters resources listed in the response.
     */
    filter?: {
        [key: string]: FilterOperation;
    } | null;
    /**
     * A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.
     */
    order_by?: string | null;
    /**
     * The agent deployment's agent_slug to aggregate data for
     */
    agent_slug: string;
    /**
     * The logical agent data collection to aggregate data for
     */
    collection?: string;
    /**
     * The fields to group by. If empty, the entire dataset is grouped on. e.g. if left out, can be used for simple count operations
     */
    group_by?: Array<string> | null;
    /**
     * Whether to count the number of items in each group
     */
    count?: boolean | null;
    /**
     * Whether to return the first item in each group (Sorted by created_at)
     */
    first?: boolean | null;
    /**
     * The offset to start from. If not provided, the first page is returned
     */
    offset?: number | null;
};
/**
 * API request model for a filter comparison operation.
 */
type FilterOperation = {
    eq?: number | number | string | null;
    gt?: number | number | string | null;
    gte?: number | number | string | null;
    lt?: number | number | string | null;
    lte?: number | number | string | null;
    includes?: Array<number | number | string | null>;
};
type PaginatedResponseAgentData = {
    /**
     * The list of items.
     */
    items: Array<AgentData>;
    /**
     * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
     */
    next_page_token?: string | null;
    /**
     * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
     */
    total_size?: number | null;
};
type PaginatedResponseAggregateGroup = {
    /**
     * The list of items.
     */
    items: Array<AggregateGroup>;
    /**
     * A token, which can be sent as page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
     */
    next_page_token?: string | null;
    /**
     * The total number of items available. This is only populated when specifically requested. The value may be an estimate and can be used for display purposes only.
     */
    total_size?: number | null;
};
/**
 * API request body for searching agent data
 */
type SearchRequest = {
    /**
     * The maximum number of items to return. The service may return fewer than this value. If unspecified, a default page size will be used. The maximum value is typically 1000; values above this will be coerced to the maximum.
     */
    page_size?: number | null;
    /**
     * A page token, received from a previous list call. Provide this to retrieve the subsequent page.
     */
    page_token?: string | null;
    /**
     * A filter object or expression that filters resources listed in the response.
     */
    filter?: {
        [key: string]: FilterOperation;
    } | null;
    /**
     * A comma-separated list of fields to order by, sorted in ascending order. Use 'field_name desc' to specify descending order.
     */
    order_by?: string | null;
    /**
     * The agent deployment's agent_slug to search within
     */
    agent_slug: string;
    /**
     * The logical agent data collection to search within
     */
    collection?: string;
    /**
     * Whether to include the total number of items in the response
     */
    include_total?: boolean;
    /**
     * The offset to start from. If not provided, the first page is returned
     */
    offset?: number | null;
};

type AgentClientOptions = {
    apiKey?: string;
    baseUrl?: string;
    collection?: string;
    agentUrlId?: string;
    windowUrl?: string;
};
/**
 * Async client for agent data operations
 */
declare class AgentClient<T = unknown> {
    private client;
    private baseUrl;
    private headers;
    private collection;
    private agentUrlId;
    constructor(options?: AgentClientOptions);
    /**
     * Create new agent data
     */
    createItem(data: T): Promise<AgentData>;
    /**
     * Get agent data by ID
     */
    getItem(id: string): Promise<AgentData | null>;
    /**
     * Update agent data
     */
    updateItem(id: string, data: T): Promise<AgentData>;
    /**
     * Delete agent data
     */
    deleteItem(id: string): Promise<void>;
    /**
     * Search agent data
     */
    search(options?: Partial<SearchRequest>): Promise<PaginatedResponseAgentData>;
    /**
     * Aggregate agent data into groups
     */
    aggregate(options?: Partial<AggregateRequest>): Promise<PaginatedResponseAggregateGroup>;
}
declare function createAgentDataClient<T = unknown>(options?: AgentClientOptions): AgentClient<T>;

/**
 * Status types for agent data processing
 */
declare const StatusType: {
    readonly ERROR: "error";
    readonly ACCEPTED: "accepted";
    readonly REJECTED: "rejected";
    readonly PENDING_REVIEW: "pending_review";
};
type StatusType = (typeof StatusType)[keyof typeof StatusType];
/**
 * Base extracted data interface
 */
interface ExtractedData<T = unknown> {
    /** The original data that was extracted from the document. For tracking changes. Should not be updated. */
    original_data: T;
    /** The latest state of the data. Will differ if data has been updated. */
    data?: T;
    /** The status of the extracted data. Prefer to use the StatusType values, but any string is allowed. */
    status: StatusType | string;
    /** Confidence scores, if any, for each primitive field in the original_data data. */
    confidence?: Record<string, unknown>;
    /** The ID of the file that was used to extract the data. */
    file_id?: string;
    /** The name of the file that was used to extract the data. */
    file_name?: string;
    /** The hash of the file that was used to extract the data. */
    file_hash?: string;
    /** Additional metadata about the extracted data, such as errors, tokens, etc. */
    metadata?: Record<string, unknown>;
}

export { AgentClient, StatusType, StatusType as StatusTypeEnum, createAgentDataClient };
export type { AgentData, AggregateGroup, AggregateRequest, ExtractedData, FilterOperation, PaginatedResponseAgentData, PaginatedResponseAggregateGroup, SearchRequest };
